/*
** Read this to understand how classes work in squirrel:
** https://r2northstar.readthedocs.io/en/latest/native/class.html
*/

untyped
global var Spaceship // This is the class! DON'T PUT ANYTHING ELSE IN THIS!

global function SpaceShipClassesInit

// table to get the corresponding instance of a prop
global table< entity, var> spaceships

struct {
	entity w1
} SpaceshipWeapons

const FX_FAR_FORWARD_EXPLOSION = $"droppod_impact_black"
const FX_FORWARD_EXPLOSION = $"P_exp_redeye_sml_elec"
const FIRE_TRAIL = $"Rocket_Smoke_Swirl_LG"

const FX_MEGA_TURRET_IMPACT_SMOKE = $"impact_exp_bomber_smoke1"
const FX_MEGA_TURRECT_IMPACT_EXPLOSION = $"P_impact_exp_XLG_air"

const FX_GOBLIN_DEATH_SIDE = $"P_veh_exp_goblin_HS"
const FX_GOBLIN_DEATH = $"P_veh_exp_crow"

void function SpaceShipClassesInit()
{
	//Precache fx
	PrecacheParticleSystem( FX_HORNET_DEATH ) // Wrong plane parts
	PrecacheParticleSystem( FX_FAR_FORWARD_EXPLOSION )
	PrecacheParticleSystem( FX_FORWARD_EXPLOSION ) // Explosion forward movement thing
	PrecacheParticleSystem( FIRE_TRAIL )
	PrecacheParticleSystem( FX_MEGA_TURRET_IMPACT_SMOKE )
	PrecacheParticleSystem( FX_MEGA_TURRECT_IMPACT_EXPLOSION )
	PrecacheParticleSystem( FX_GOBLIN_DEATH )

	// add a property to the player class to store their ship
	CPlayer.spaceship <- null

	AddCallback_GameStateEnter( eGameState.Prematch, void function(){
		// helper entity that stays alive the whole game hopefully
		entity guy = CreateSoldier( TEAM_UNASSIGNED,<0,0,0>,<0,0,0> )
		MakeInvincible( guy )
		// guy.Hide()
		guy.ReplaceActiveWeapon("mp_weapon_epg")
		SpaceshipWeapons.w1 = guy.GetMainWeapons()[0]
	} )



	class Spaceship {
		// ship.GetOwner() for pilot
		ship = null // CDynamicProp
		mover = null // script_mover
		weapon = null // CWeaponX
		engineOn = false // boolean
		moveTime = 0.5 // float
		inManeuver = false // boolean
		freeView = false // boolean
		moveSlow = false
		health = 400 // ship health

		startManeuverTime = 1.5
		landingManeuverTime = 1.5

		constructor( var origin, var angles )
		{
			expect vector( origin )
			expect vector( angles )

			// create the ship prop
			this.ship = CreateEntity( "prop_script" )
			this.ship.SetValueForModelKey( $"models/vehicle/straton/straton_imc_gunship_01.mdl" )
			this.ship.SetAngles( angles )
			this.ship.SetOrigin( origin )
			this.ship.kv.solid = SOLID_VPHYSICS
			AddEntityCallback_OnDamaged( expect entity( this.ship ), OnShipDamaged )
			DispatchSpawn( expect entity( this.ship ) )

			this.ship.SetScriptName( UniqueString( "ship" ) )

			this.ship.SetMaxHealth( expect int( this.health ) )
			this.ship.SetHealth( expect int( this.health ) )

			this.SetShipFree()

			AddCallback_OnUseEntity( expect entity( this.ship ), OnShipUsed)

			// create the ship mover
			vector shipAngles = expect vector( this.ship.EyeAngles() )
			this.mover = CreateExpensiveScriptMover( origin, <0, shipAngles.y, shipAngles.z> )

			this.ship.SetParent( this.mover )

			spaceships[expect entity( this.ship )] <- this

			// create ship weapon reference
			this.weapon = SpaceshipWeapons.w1

			thread this.MoveShip()
			thread this.RotateShip()
			thread this.ClippingCheck()
		}

		function SetShipFree() /* void */
		{
			this.ship.SetUsableByGroup( "pilot" )
			this.ship.SetUsePrompts( "Press %use% to enter", "Press %use% to enter")
		}

		function SetShipOccupied() /* void */
		{
			this.ship.UnsetUsable()
			// printt( this.ship.GetOwner() )
			// this.ship.SetUsableByGroup( "owner pilot" )
			// this.ship.SetUsePrompts( "Press %use% to exit", "Press %use% to exit")
		}

		function Embark( /* CPlayer */ var player ) // void
		{
			expect entity( player )
			this.ship.SetOwner( player )
			player.spaceship = this

			player.DisableWeaponViewModel()
			player.ForceStand()

			vector shipAngles = expect vector( this.ship.EyeAngles() )
			vector shipOrigin = expect vector( this.ship.GetOrigin() )

			vector au = AnglesToUp( shipAngles )
			vector af = AnglesToForward( shipAngles )



			player.SetOrigin( shipOrigin + af * 120 + au * 37  ) //line up player with ship
			player.SetAngles(<0,shipAngles.y,shipAngles.z>)

			player.SetParent( this.mover )


			AddButtonPressedPlayerInputCallback( expect entity(this.ship.GetOwner()), IN_JUMP , OnJumpInput ) // starting / landing
			AddButtonPressedPlayerInputCallback( expect entity(this.ship.GetOwner()), IN_DUCK , OnExitUsed ) // exiting
			AddButtonPressedPlayerInputCallback( expect entity(this.ship.GetOwner()), IN_ZOOM , OnFreeViewPressed ) // freeview start
			AddButtonReleasedPlayerInputCallback( expect entity(this.ship.GetOwner()), IN_ZOOM, OnFreeViewReleased ) // freeview end
			AddButtonPressedPlayerInputCallback(expect entity(this.ship.GetOwner()), IN_BACK, OnMoveSlowPressed ) // move slow start
			AddButtonReleasedPlayerInputCallback( expect entity(this.ship.GetOwner()), IN_BACK, OnMoveSlowReleased ) // move slow end
			AddButtonPressedPlayerInputCallback( expect entity(this.ship.GetOwner()), IN_ATTACK, OnAttackPressed ) // ship attack

			this.SetShipOccupied()
		}

		function Disembark(var shouldeject) /* void */
		{
			entity player = expect entity( this.ship.GetOwner() )
			player.spaceship = null

			player.ClearParent()
			player.UnforceStand()
			this.ship.GetOwner().EnableWeaponViewModel()

			if( this.engineOn && expect bool(shouldeject) == true )
				this.Eject()

			this.ship.SetOwner( null )
			this.SetShipFree()

			RemoveButtonPressedPlayerInputCallback( player, IN_JUMP , OnJumpInput )
			RemoveButtonPressedPlayerInputCallback( player, IN_DUCK , OnExitUsed )
			RemoveButtonPressedPlayerInputCallback( player, IN_ZOOM , OnFreeViewPressed )
			RemoveButtonReleasedPlayerInputCallback( player, IN_ZOOM, OnFreeViewReleased )
			RemoveButtonPressedPlayerInputCallback( player, IN_BACK, OnMoveSlowPressed )
			RemoveButtonReleasedPlayerInputCallback( player, IN_BACK, OnMoveSlowReleased )
			RemoveButtonPressedPlayerInputCallback( player, IN_ATTACK, OnAttackPressed )



		}

		function Eject() /* void */
		{
			entity player = expect entity( this.ship.GetOwner() )
			player.SetVelocity( player.GetVelocity() + <0,0,1000> )
		}

		function MoveShip() /* void */
		{
			while ( IsValid( expect entity( this.ship ) ) && IsValid(expect entity(this.mover)))
			{
				if ( this.engineOn )
				{
					float moveTime = expect float( this.moveTime )
					if ( this.moveSlow )
						moveTime = moveTime * 3.5
					this.mover.NonPhysicsMoveTo(
						expect vector( this.ship.GetOrigin() + this.ship.GetForwardVector() * 500 ),
						moveTime ,0,0.2 )
				}
				wait 0.1
			}
		}

		function RotateShip() /* void */
		{
			while( IsValid( expect entity( this.ship ) ) ) {
				if ( !this.ship || !this.mover || !this.ship.GetOwner() || !this.engineOn || this.freeView )
				{
					WaitFrame()
					continue
				} else if ( IsValid( expect entity( this.ship ) ) )
				{
					vector v = expect vector( this.ship.GetOwner().EyeAngles() )
					v = <v.x,v.y,0>

					// move for 0.5 seconds to account for higher ping maybe?
					// with a lower move time the view sometimes starts "stuttering"
					this.mover.NonPhysicsRotateTo(v, 0.3, 0, 0)

					// actually rotate every 0.1 seconds
					// this means that the player waits for 0.1 seconds before moving!
					wait 0.01
				}
			}
		}


		function ClippingCheck() {
			while ( IsValid( expect entity( this.ship ) ) )
			{
				if ( this.engineOn )
				{
					entity ent = expect entity (this.ship)
					int solidMask = TRACE_MASK_PLAYERSOLID
					vector orinal_pos = ent.GetOrigin()


					TraceResults result

					vector mins = < -100, -100,0>
					vector maxs = < 100,100,70>

					result = TraceHull( orinal_pos , orinal_pos, mins, maxs, [], solidMask, TRACE_COLLISION_GROUP_DEBRIS )
					if ( IsValid( result.hitEnt )  ){
						//if(IsValid(this.ship.GetOwner())){this.ship.GetOwner().SetHealth(0)}
						this.Explode()
					}


				}
				WaitFrame()
			}
		}

		function StartingSequence() /* void */
		{
			if ( this.inManeuver )
				return

			this.mover.NonPhysicsMoveTo(
				expect vector( this.ship.GetOrigin() + <0,0,500> ),
				expect float( this.startManeuverTime ), 0.5,0.5 )

			thread void function() {
				this.inManeuver = true
				wait expect float( this.startManeuverTime )
				this.engineOn = true
			}()

			this.inManeuver = false
		}

		function LandingSequence( /* vector */ landingSpot) /* void */
		{
			if ( this.inManeuver )
				return

			this.engineOn = false


			vector distant = expect vector( this.ship.GetOrigin() ) + expect vector( this.ship.GetForwardVector() ) * 500
			float t = expect float( this.moveTime )
			this.mover.NonPhysicsMoveTo( distant, t, 0, t )
			// this.mover.NonPhysicsMoveTo(
			// 	expect vector( landingSpot ), t, 0, 0 ) // moving is controlled by movers and they can't move for 0 secs
			vector angles = expect vector( this.mover.GetAngles() )
			this.mover.RotateTo(<0,angles.y,0>, expect float( this.landingManeuverTime ), t / 3, t / 3 )

			thread void function( float t, vector landingSpot ) {
				this.inManeuver = true
				wait t + 0.5
				this.mover.NonPhysicsMoveTo( landingSpot, expect float( this.landingManeuverTime ), t / 3, t / 3 )
				wait t
			}( t, expect vector( landingSpot ) )

			this.inManeuver = false
		}

		function Shipshoot() {

			EmitSoundOnEntity( expect entity(this.ship.GetOwner()) , "weapon_epg_fire_1p" )

			entity guy = CreateSoldier(TEAM_BOTH,expect vector(this.ship.GetOrigin()),expect vector(this.ship.GetAngles()))
			DispatchSpawn( guy )
			guy.Hide()
			guy.ReplaceActiveWeapon("mp_weapon_arena2")
			entity weapon = guy.GetMainWeapons()[0]

			vector shootvector = <this.ship.GetForwardVector().x,this.ship.GetForwardVector().y,this.ship.GetForwardVector().z + 0.1> //slightly up
			weapon.FireWeaponMissile( expect vector(this.ship.GetOrigin()+this.ship.GetForwardVector() * 250 ),shootvector	, 1.0, damageTypes.largeCaliberExp, damageTypes.largeCaliberExp, true, PROJECTILE_NOT_PREDICTED )


   		    guy.Destroy()
    		weapon.Destroy()
		}

		function Explode() {
			this.ship.ClearParent()



			if( this.ship.GetOwner() && this.engineOn){
				this.Disembark(true)
			} else if(this.ship.GetOwner()) {
				this.Disembark(false)
			}

			
			if (IsValid(this.ship)){this.ship.Destroy()}
			if(IsValid(this.mover)){this.mover.Destroy()}




			vector au = AnglesToUp( this.ship.GetAngles() )

			PlayFX(FX_MEGA_TURRECT_IMPACT_EXPLOSION,expect vector (this.ship.GetOrigin()) + expect vector(this.ship.GetForwardVector() * -150 + au * 100))
		}

	}
}

void function OnShipDamaged( entity ship, var damageInfo )
{
	if ( !IsValid( ship ) )
		return

	// ship.Destroy()

	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	float damageAmount = DamageInfo_GetDamage( damageInfo )

	if ( !damageSourceID && !damageAmount && !attacker )
		return


	float newHealth = ship.GetHealth() - damageAmount
	ship.SetHealth( newHealth )

	if( newHealth < 0 )
	{
		var spaceship = spaceships[ship]
		spaceship.Explode()
	}
}

var function OnShipUsed( var prop, var player )
{
	expect entity( prop )
	var spaceship = spaceships[prop]

	spaceship.ship.SetOwner( player )
	spaceship.Embark( player )
}

void function OnExitUsed( entity player )
{
	if ( !this.player.spaceship )
		return

	var spaceship = player.spaceship
	if ( spaceship )
		player.spaceship.Disembark(true)
}

void function OnJumpInput( entity player )
{
	if ( !this.player.spaceship )
		return

	if ( player.spaceship.engineOn )
	{
		TraceResults results = TraceLandingSpot( expect entity( player.spaceship.ship ) )
		if ( results.hitEnt && results.hitEnt.IsWorld() )
			player.spaceship.LandingSequence( results.endPos + <0,0,5> )
	}
	else
		player.spaceship.StartingSequence()
}

void function OnFreeViewPressed( entity player )
{
	if ( this.player.spaceship )
		this.player.spaceship.freeView = true
}

void function OnFreeViewReleased( entity player )
{
	if ( this.player.spaceship )
		this.player.spaceship.freeView = false
}

void function OnMoveSlowPressed( entity player )
{
	player.spaceship.moveSlow = true
}

void function OnMoveSlowReleased( entity player )
{
	player.spaceship.moveSlow = false
}

void function OnAttackPressed( entity player )
{
	player.spaceship.Shipshoot()
}

TraceResults function TraceLandingSpot( entity shipProp )
{
	vector distant = shipProp.GetOrigin() + shipProp.GetForwardVector() * 500
	vector traceStart = shipProp.GetOrigin()
	vector traceEnd = distant - <0,0,400 /* this is the max height from which landings are allowed*/>

	return TraceLine( distant, traceEnd, null, TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )
}

