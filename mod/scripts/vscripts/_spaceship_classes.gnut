/*
** Read this to understand how classes work in squirrel:
** https://r2northstar.readthedocs.io/en/latest/native/class.html
*/

untyped
global var Spaceship // This is the class! DON'T PUT ANYTHING ELSE IN THIS!

global function SpaceShipClassesInit

// table to get the corresponding instance of a prop
global table< entity, var> spaceships


const FX_MEGA_TURRECT_IMPACT_EXPLOSION = $"P_impact_exp_XLG_air"

const SPACESHIP_MAX_LANDING_HEIGHT = 400




void function SpaceShipClassesInit()
{
	// Precache models
	PrecacheModel($"models/vehicle/straton/straton_imc_gunship_01.mdl")
	PrecacheModel($"models/vehicle/crow_dropship/crow_dropship_hero.mdl")
	PrecacheModel($"models/vehicle/goblin_dropship/goblin_dropship_hero.mdl")


	//Precache fx
	PrecacheParticleSystem( FX_MEGA_TURRECT_IMPACT_EXPLOSION )


	// add a property to the player class to store their ship
	CPlayer.spaceship <- null

	class Spaceship {
		// ship.GetOwner() for pilot
		config = null // table			| config data for different spaceship types
		ship = null // CDynamicProp		| holds the ingame prop of the ship
		mover = null // script_mover	| moves the player and prop
		engineOn = false // boolean		| controls if the spaceship is allowed to move
		moveTime = 0.5 // float			| time of the mover to move to the next point
		inManeuver = false // boolean	| true if the ship is landing / starting <> replace this with signals maybe
		freeView = false // boolean		| true when the player is not changing directions with view
		moveSlow = false // boolean		| move slowly, still very janky
		startManeuverTime = 1.5
		landingManeuverTime = 1.5

		// ships can't be damaged by a ship of the same team. Also applies to TEAM_UNSASSIGNED
		constructor( string type , var origin = <0,0,0>, var angles = <0,0,0>, team = TEAM_UNASSIGNED )
		{
			expect vector( origin )
			expect vector( angles )

			this.config = this.ConfigFromType( type )

			// create the ship prop
			this.ship = CreateEntity( "prop_script" )
			this.ship.SetValueForModelKey( expect asset( this.config.model ) )
			this.ship.SetAngles( angles )
			this.ship.SetOrigin( origin + < 0, 0, expect float( this.config.groundToFeet ) > )
			this.ship.kv.solid = SOLID_VPHYSICS
			// this.ship.SetArmorType( ARMOR_TYPE_HEAVY )
			AddEntityCallback_OnDamaged( expect entity( this.ship ), OnShipDamaged )

			DispatchSpawn( expect entity( this.ship ) )

			this.ship.SetScriptName( UniqueString( "ship" ) )

			this.ship.SetMaxHealth( expect int( this.config.health ) )
			this.ship.SetHealth( expect int( this.config.health ) )

			this.SetShipFree()

			AddCallback_OnUseEntity( expect entity( this.ship ), OnShipUsed)

			// create the ship mover
			vector shipAngles = expect vector( this.ship.EyeAngles() )
			this.mover = CreateExpensiveScriptMover( origin, <0, shipAngles.y, shipAngles.z> )

			this.ship.SetParent( this.mover )

			spaceships[expect entity( this.ship )] <- this

			thread this.MoveShip()
			thread this.RotateShip()


		}



		function SetShipFree() /* void */
		{
			this.ship.SetUsableByGroup( "pilot" )
			this.ship.SetUsePrompts( "Press %use% to enter", "Press %use% to enter")
		}

		function SetShipOccupied() /* void */
		{
			this.ship.UnsetUsable()
		}

		function Embark( /* CPlayer */ var player ) // void
		{
			expect entity( player )
			this.ship.SetOwner( player )
			player.spaceship = this

			player.DisableWeaponViewModel()

			vector shipAngles = expect vector( this.ship.EyeAngles() )
			vector shipOrigin = expect vector( this.ship.GetOrigin() )
			player.SetAngles(<0,shipAngles.y,shipAngles.z>)


			vector af = AnglesToForward( shipAngles )

			float forwardCorrection = expect float( this.config.cockpitForwardCorrection )
			float upwardCorrection = expect float( this.config.cockpitUpwardCorrection )
			if (!player.IsOnGround() && player.IsCrouched()) {upwardCorrection = upwardCorrection + 12} //when entering in the air and is crouched it needs an offset dk why

			player.SetOrigin( shipOrigin + af * forwardCorrection   +  <0,0,upwardCorrection> )
			player.SetAngles( shipAngles )

			player.SetParent( this.mover )

			player.ForceStand()

			AddButtonPressedPlayerInputCallback( player, IN_JUMP , OnJumpInput ) // starting / landing
			AddButtonPressedPlayerInputCallback( player, IN_DUCK , OnExitUsed ) // exiting
			AddButtonPressedPlayerInputCallback( player, IN_ZOOM , OnFreeViewPressed ) // freeview start
			AddButtonReleasedPlayerInputCallback( player, IN_ZOOM, OnFreeViewReleased ) // freeview end
			AddButtonPressedPlayerInputCallback( player, IN_BACK, OnMoveSlowPressed ) // move slow start
			AddButtonReleasedPlayerInputCallback( player, IN_BACK, OnMoveSlowReleased ) // move slow end
			AddButtonPressedPlayerInputCallback( player, IN_ATTACK, OnAttackPressed ) // ship attack
			AddButtonReleasedPlayerInputCallback( player, IN_ATTACK, OnAttackReleased ) // ship attack

			this.SetShipOccupied()


			AddDeathCallback( "player", OnPilotDeath )

			this.ship.Code_SetTeam( player.GetTeam() )
		}

		function Disembark() /* void */
		{
			entity player = expect entity( this.ship.GetOwner() )
			player.spaceship = null

			player.ClearParent()
			player.UnforceStand()
			this.ship.GetOwner().EnableWeaponViewModel()

			if( this.engineOn && IsValid( player ) )
				this.Eject()

			this.ship.SetOwner( null )
			this.SetShipFree()

			DeregisterAllButtons( player )

			RemoveDeathCallback( "player", OnPilotDeath )

			this.ship.Code_SetTeam( TEAM_UNASSIGNED )
		}

		function Eject() /* void */
		{
			entity player = expect entity( this.ship.GetOwner() )
			player.SetVelocity( player.GetVelocity() + <0,0,1000> )
		}

		function MoveShip() /* void */
		{
			while ( IsValid( expect entity( this.ship ) ) )
			{
				if ( this.engineOn )
				{
					float moveTime = expect float( this.config.moveTime )
					if ( this.moveSlow )
						moveTime = moveTime * 2
					vector moveTo = expect vector( this.ship.GetOrigin() + this.ship.GetForwardVector() * 500 )

					this.mover.NonPhysicsMoveTo( moveTo, moveTime , 0, 0.2 )
				}
				wait 0.1
			}
		}

		function RotateShip() /* void */
		{
			// entity prop
			while( IsValid( expect entity( this.ship ) ) ) {
				if ( !this.ship || !this.mover || !this.ship.GetOwner() || !this.engineOn || this.freeView )
				{
					WaitFrame()
					continue
				} else if ( IsValid( expect entity( this.ship ) ) )
				{
					vector v = expect vector( this.ship.GetOwner().EyeAngles() )
					v = <v.x,v.y,0>

					// move for 0.5 seconds to account for higher ping maybe?
					// with a lower move time the view sometimes starts "stuttering"
					this.mover.NonPhysicsRotateTo(v, 0.3, 0, 0)

					// actually rotate every 0.01 seconds
					// this means that the player waits for 0.1 seconds before moving!
					wait 0.01
				}
			}
		}

		function StartingSequence() /* void */
		{
			if ( this.inManeuver )
				return

			this.mover.ClearParent()

			this.mover.NonPhysicsMoveTo(
				expect vector( this.ship.GetOrigin() + <0,0,200> ),
				expect float( this.startManeuverTime ), 0.5,0.5 )

			thread void function() {
				this.inManeuver = true
				wait expect float( this.startManeuverTime )
				this.engineOn = true
			}()

			this.inManeuver = false

		}

		function LandingSequence( /* vector */ landingSpot) /* void */
		{
			if ( this.inManeuver )
				return

			this.engineOn = false

			vector distant = expect vector( this.ship.GetOrigin() ) + expect vector( this.ship.GetForwardVector() ) * 500
			float t = expect float( this.config.moveTime )
			this.mover.NonPhysicsMoveTo( distant, t, 0, t )

			vector angles = expect vector( this.mover.GetAngles() )
			this.mover.RotateTo(<0,angles.y,0>, expect float( this.landingManeuverTime ), t / 3, t / 3 )

			thread void function( float t, vector landingSpot ) {
				this.inManeuver = true
				wait t + 0.5
				this.mover.NonPhysicsMoveTo( landingSpot, expect float( this.landingManeuverTime ), t / 3, t / 3 )
				wait t
			}( t, expect vector( landingSpot ) )

			this.inManeuver = false
		}

		function ConfigFromType( string type )
		{
			var config = {} // fml. Can't use structs and tables because untyped is shit
			switch( type ) {
				case "goblin":
					table barrel = {
						cannonPosForward = 315.0
						cannonPosRight = 0.0
						cannonPosUp = -70.0
					}

					config.model <- $"models/vehicle/goblin_dropship/goblin_dropship_hero.mdl"
					config.cockpitForwardCorrection <- 310.0
					config.cockpitUpwardCorrection <- -60.0
					config.explosions <- [ FX_MEGA_TURRECT_IMPACT_EXPLOSION ]
					config.health <- 800
					config.moveTime <- 0.7
					config.groundToFeet <- 100.0
				break
				case "crow":
					table barrel = {
						cannonPosForward = 300.0
						cannonPosRight = 0.0
						cannonPosUp = -50.0
					}

					config.model <- $"models/vehicle/crow_dropship/crow_dropship_hero.mdl"
					config.cockpitForwardCorrection <- 270.0
					config.cockpitUpwardCorrection <- -35.0
					config.explosions <- [ FX_MEGA_TURRECT_IMPACT_EXPLOSION ]
					config.health <- 500
					config.moveTime <- 1.0
					config.groundToFeet <- 100.0
				break
				case "straton":
				default:
					table barrel1 = {
						cannonPosForward = 250.0
						cannonPosRight = 22.5
						cannonPosUp = 40.0
					}
					table barrel2 = {
						cannonPosForward = 250.0
						cannonPosRight = 22.5
						cannonPosUp = 32.5
					}
					table barrel3 = {
						cannonPosForward = 250.0
						cannonPosRight = -22.5
						cannonPosUp = 40.0
					}
					table barrel4 = {
						cannonPosForward = 250.0
						cannonPosRight = -22.5
						cannonPosUp = 32.5
					}

					config.model <- $"models/vehicle/straton/straton_imc_gunship_01.mdl"
					config.cockpitForwardCorrection <- 120.0
					config.cockpitUpwardCorrection <- 37.0
					config.explosions <- [ FX_MEGA_TURRECT_IMPACT_EXPLOSION ]
					config.health <- 300
					config.moveTime <- 0.5
					config.groundToFeet <- 0.0
				break
			}
			return config
		}
	}
}

void function OnShipDamaged( entity ship, var damageInfo )
{
	if ( !IsValid( ship ) )
		return

	// ship.Destroy()

	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	float damageAmount = DamageInfo_GetDamage( damageInfo )

	if ( !damageSourceID && !damageAmount && !attacker )
		return


	float newHealth = ship.GetHealth() - damageAmount
	ship.SetHealth( newHealth )

	if( newHealth <= 0 )
	{
		ship.ClearParent()
		var spaceship = spaceships[ ship ]
		if( spaceship.ship.GetOwner() )
		{
			spaceship.ship.GetOwner().ClearParent()
			spaceship.Disembark()
		}


		spaceship.mover.Destroy()

		PlayFX( FX_MEGA_TURRECT_IMPACT_EXPLOSION,  ship.GetOrigin() /* + < 0, 0, expect float( spaceships[ ship ].config.groundToFeet ) > */ )
	}

	// Remote_CallFunction_NonReplay( GetPlayerArray()[0], "Server_SetSpaceshipHealthBar", newHealth )
}





/////////////////////////////////////Input-Callbacks//////////////////////////////////////////////////

var function OnShipUsed( var prop, var player )
{
	expect entity( prop )
	var spaceship = spaceships[prop]

	spaceship.ship.SetOwner( player )
	spaceship.Embark( player )
}

void function OnExitUsed( entity player )
{
	if ( !player.spaceship )
		return

	var spaceship = player.spaceship
	if ( spaceship )
		player.spaceship.Disembark()
}

void function OnJumpInput( entity player )
{
	if ( !player.spaceship )
		return

	if ( player.spaceship.engineOn )
	{
		TraceResults results = TraceLandingSpot( expect entity( player.spaceship.ship ) )
		// if ( results.hitEnt && results.hitEnt.IsWorld() )
		if ( results.hitEnt )
		{
			player.spaceship.LandingSequence( results.endPos + <0,0,5> )
			player.spaceship.mover.SetParent( results.hitEnt )
		}
	}
	else
		player.spaceship.StartingSequence()
}

void function OnFreeViewPressed( entity player )
{
	if ( player.spaceship )
		player.spaceship.freeView = true
}

void function OnFreeViewReleased( entity player )
{
	if ( player.spaceship )
		player.spaceship.freeView = false
}

void function OnMoveSlowPressed( entity player )
{
	player.spaceship.moveSlow = true
}

void function OnMoveSlowReleased( entity player )
{
	player.spaceship.moveSlow = false
}

void function OnAttackPressed( entity player )
{
	print("fired")
}

void function OnAttackReleased( entity player )
{


}

void function OnPilotDeath( entity player, var damageInfo )
{
	player.spaceship.Disembark()
}





/////////////////////////////////////Utility//////////////////////////////////////////////////

TraceResults function TraceLandingSpot( entity shipProp )
{
	vector distant = shipProp.GetOrigin() + shipProp.GetForwardVector() * 500
	vector traceStart = shipProp.GetOrigin()
	vector traceEnd = distant - < 0, 0, SPACESHIP_MAX_LANDING_HEIGHT >

	printt( TraceLine( distant, traceEnd, null, TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE ).endPos )

	return TraceLine( distant, traceEnd, null, TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )
}

void function DeregisterAllButtons( entity player )
{
	RemoveButtonPressedPlayerInputCallback( player, IN_JUMP , OnJumpInput )
	RemoveButtonPressedPlayerInputCallback( player, IN_DUCK , OnExitUsed )
	RemoveButtonPressedPlayerInputCallback( player, IN_ZOOM , OnFreeViewPressed )
	RemoveButtonReleasedPlayerInputCallback( player, IN_ZOOM, OnFreeViewReleased )
	RemoveButtonPressedPlayerInputCallback( player, IN_BACK, OnMoveSlowPressed )
	RemoveButtonReleasedPlayerInputCallback( player, IN_BACK, OnMoveSlowReleased )
	RemoveButtonPressedPlayerInputCallback( player, IN_ATTACK, OnAttackPressed )
	RemoveButtonReleasedPlayerInputCallback( player, IN_ATTACK, OnAttackReleased )
}
